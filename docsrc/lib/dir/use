[% TAGS star %]
=item USE

The USE directive can be used to load and initialise "plugin"
extension modules.

    [% USE myplugin %]

A plugin is a regular Perl module that conforms to a particular
object-oriented interface, allowing it to be loaded into and used
automatically by the Template Toolkit.  For details of this interface
and information on writing plugins, consult L<Template::Plugin>. 

A number of standard plugins are included with the Template Toolkit
(see below and L<Template::Manual::Plugins>).  The names of these
standard plugins are case insensitive.  

    [% USE CGI   %]        # => Template::Plugin::CGI
    [% USE Cgi   %]        # => Template::Plugin::CGI
    [% USE cgi   %]        # => Template::Plugin::CGI

You can also define further plugins using the PLUGINS option.  

    my $tt = Template->new({
        PLUGINS => {
            foo => 'My::Plugin::Foo',
            bar => 'My::Plugin::Bar',
        },
    });

The recommended convention is to specify these plugin names in lower
case.  The Template Toolkit first looks for an exact case-sensitive
match and then tries the lower case conversion of the name specified.

    [% USE Foo %]      # look for 'Foo' then 'foo'

If you define all your PLUGINS with lower case names then they will be
located regardless of how the user specifies the name in the USE
directive.  If, on the other hand, you define your PLUGINS with upper
or mixed case names then the name specified in the USE directive must
match the case exactly.  

If the plugin isn't defined in either the standard plugins
($Template::Plugins::STD_PLUGINS) or via the PLUGINS option, then 
the PLUGIN_BASE is searched.

In this case the plugin name I<is> case-sensitive.  It is appended to
each of the PLUGIN_BASE module namespaces in turn (default:
'Template::Plugin') to construct a full module name which it attempts
to locate and load.  Any periods, '.', in the name will be converted
to '::'.

    [% USE MyPlugin %]     #  => Template::Plugin::MyPlugin
    [% USE Foo.Bar  %]     #  => Template::Plugin::Foo::Bar

The LOAD_PERL option (disabled by default) provides a further way by
which external Perl modules may be loaded.  If a regular Perl module
(i.e. not a Template::Plugin::* or other module relative to some
PLUGIN_BASE) supports an object-oriented interface and a new()
constructor then it can be loaded and instantiated automatically.  The
following trivial example shows how the IO::File module might be used.

    [% USE file = IO.File('/tmp/mydata') %]

    [% WHILE (line = file.getline) %]
       <!-- [% line %] -->
    [% END %]

Any additional parameters supplied in parenthesis after the plugin
name will be also be passed to the new() constructor.  A reference to
the current Template::Context object is passed as the first
parameter.

    [% USE MyPlugin('foo', 123) %]

equivalent to:

    Template::Plugin::MyPlugin->new($context, 'foo', 123);

The only exception to this is when a module is loaded via the
LOAD_PERL option.  In this case the $context reference is I<not>
passed to the new() constructor.  This is based on the assumption that
the module is a regular Perl module rather than a Template Toolkit
plugin so isn't expecting a context reference and wouldn't know what
to do with it anyway.

Named parameters may also be specified.  These are collated into a
hash which is passed by reference as the last parameter to the
constructor, as per the general code calling interface.

    [% USE url('/cgi-bin/foo', mode='submit', debug=1) %]

equivalent to:

    Template::Plugin::URL->new($context, '/cgi-bin/foo'
			       { mode => 'submit', debug => 1 });

The plugin may represent any data type; a simple variable, hash, list or
code reference, but in the general case it will be an object reference.
Methods can be called on the object (or the relevant members of the
specific data type) in the usual way:

    [% USE table(mydata, rows=3) %]

    [% FOREACH row = table.rows %]
       <tr>    
       [% FOREACH item = row %]
	  <td>[% item %]</td>
       [% END %]
       </tr>
    [% END %]

An alternative name may be provided for the plugin by which it can be 
referenced:

    [% USE scores = table(myscores, cols=5) %]

    [% FOREACH row = scores.rows %]
       ...
    [% END %]

You can use this approach to create multiple plugin objects with
different configurations.  This example shows how the 'format' plugin
is used to create sub-routines bound to variables for formatting text
as per printf().

    [% USE bold = format('<b>%s</b>') %]
    [% USE ital = format('<i>%s</i>') %]

    [% bold('This is bold')   %]
    [% ital('This is italic') %]

Output:

    <b>This is bold</b>
    <i>This is italic</i>

This next example shows how the URL plugin can be used to build
dynamic URLs from a base part and optional query parameters.

    [% USE mycgi = URL('/cgi-bin/foo.pl', debug=1) %]
    <a href="[% mycgi %]">...
    <a href="[% mycgi(mode='submit') %]"...

Output:

    <a href="/cgi-bin/foo.pl?debug=1">...
    <a href="/cgi-bin/foo.pl?mode=submit&debug=1">...

The CGI plugin is an example of one which delegates to another Perl
module.  In this this case, it is to Lincoln Stein's CGI.pm module.
All of the methods provided by CGI.pm are available via the plugin.

    [% USE CGI %]

    [% CGI.start_form %]

    [% CGI.checkbox_group(name   =>   'colours', 
                          values => [ 'red' 'green' 'blue' ])
    %]

    [% CGI.popup_menu(name   =>   'items', 
                      values => [ 'foo' 'bar' 'baz' ])
    %]

    [% CGI.end_form %]

Simon Matthews has written the DBI plugin which provides an interface
to Tim Bunce's DBI module (available from CPAN).  Here's a short
example:

    [% USE DBI('DBI:mSQL:mydbname') %]

    [% FOREACH user = DBI.query('SELECT * FROM users') %]
       [% user.id %] [% user.name %] [% user.etc.etc %]
    [% END %]

See L<Template::Manual::Plugins> for more information on the plugins
distributed with the toolkit or available from CPAN.


