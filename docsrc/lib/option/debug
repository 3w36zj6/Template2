[% TAGS star %]
[* DEFAULT 
   obj = '$template'
   pkg = 'Template'
-*]
=item DEBUG

The DEBUG option can be used to enable debugging within the various
different modules that comprise the Template Toolkit.  The
L<Template::Constants|Template::Constants> module defines a set of
DEBUG_XXXX constants which can be combined using the logical OR
operator, '|'.

    use Template::Constants qw( :debug );

    my [* obj *] = [* pkg *]->new({
	DEBUG => DEBUG_PARSER | DEBUG_PROVIDER,
    });

For convenience, you can also provide a string containing a list
of lower case debug options, separated by any non-word characters.

    my [* obj *] = [* pkg *]->new({
	DEBUG => 'parser, provider',
    });

The following DEBUG_XXXX flags can be used:

=over 4

[* FOREACH opt = [ 'service', 'context', 'provider', 'plugins',
                   'filters', 'parser', 'undef', 'dirs', 'all', 'caller' ] -*]
=item DEBUG_[* opt | upper *]

[*+ PROCESS "option/debug_opt/$opt" | trim +*]

[* END -*]

=back

=item DEBUG_FORMAT

The DEBUG_FORMAT option can be used to specify a format string for the
debugging messages generated via the DEBUG_DIRS option described
above.  Any occurances of C<$file>, C<$line> or C<$text> will be
replaced with the current file name, line or directive text,
respectively.  Notice how the format is single quoted to prevent Perl
from interpolating those tokens as variables.

    my [* obj *] = [* pkg *]->new({
	DEBUG => 'dirs',
	DEBUG_FORMAT => '<!-- $file line $line : [% $text %] -->',
    });

The following template fragment:

    [% foo = 'World' %]
    Hello [% foo %]

would then generate this output:

    <!-- input text line 2 : [% foo = 'World' %] -->
    Hello <!-- input text line 3 : [% foo %] -->World

The DEBUG directive can also be used to set a debug format within
a template.

    [% DEBUG format '<!-- $file line $line : [% $text %] -->' %]
