[% DEFAULT 
   obj = '$template'
   pkg = 'Template'
-%]
=item LOAD_TEMPLATES

The LOAD_TEMPLATE option can be used to provide a reference to a list
of Template::Provider objects or sub-classes thereof which will take
responsibility for loading and compiling templates.

    my [% obj %] = [% pkg %]->new({
	LOAD_TEMPLATES => [
    	    MyOrg::Template::Provider->new({ ... }),
    	    Template::Provider->new({ ... }),
	],
    });

When a PROCESS, INCLUDE or WRAPPER directive is encountered, the named
template may refer to a locally defined BLOCK or a file relative to
the INCLUDE_PATH (or an absolute or relative path if the appropriate
ABSOLUTE or RELATIVE options are set).  If a BLOCK definition can't be
found (see the Template::Context template() method for a discussion of
BLOCK locality) then each of the LOAD_TEMPLATES provider objects is
queried in turn via the fetch() method to see if it can supply the
required template.  Each provider can return a compiled template, an
error, or decline to service the request in which case the
responsibility is passed to the next provider.  If none of the
providers can service the request then a 'not found' error is
returned.  The same basic provider mechanism is also used for the 
INSERT directive but it bypasses any BLOCK definitions and doesn't
attempt is to parse or process the contents of the template file.

This is an implementation of the 'Chain of Responsibility'
design pattern as described in 
[% INCLUDE refs/despat page='223' %].

If LOAD_TEMPLATES is undefined, a single default provider will be
instantiated using the current configuration parameters.  For example,
the Template::Provider INCLUDE_PATH option can be specified in the [%
pkg %] configuration and will be correctly passed to the provider's
constructor method.

    my [% obj %] = [% pkg %]->new({
	INCLUDE_PATH => '/here:/there',
    });

