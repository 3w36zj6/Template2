[% TAGS star %]
[* DEFAULT 
   obj = '$template'
   pkg = 'Template'
-*]

=item PLUGIN_BASE

If a plugin is not defined in the PLUGINS hash then the PLUGIN_BASE is used
to attempt to construct a correct Perl module name which can be successfully 
loaded.  

The PLUGIN_BASE can be specified as a reference to an array of module
namespaces, or as a single value which is automatically converted to a
list.  The default PLUGIN_BASE value ('Template::Plugin') is then added
to the end of this list.

example 1:

    my [* obj *] = [* pkg *]->new({
        PLUGIN_BASE => 'MyOrg::Template::Plugin',
    });

    [% USE Foo %]    # => MyOrg::Template::Plugin::Foo
                       or        Template::Plugin::Foo 

example 2:

    my [* obj *] = [* pkg *]->new({
        PLUGIN_BASE => [   'MyOrg::Template::Plugin',
                           'YourOrg::Template::Plugin'  ],
    });

    [% USE Foo %]    # =>   MyOrg::Template::Plugin::Foo
                       or YourOrg::Template::Plugin::Foo 
                       or          Template::Plugin::Foo 

If you don't want the default Template::Plugin namespace added to the
end of the PLUGIN_BASE, then set the $Template::Plugins::PLUGIN_BASE
variable to a false value before calling the [* pkg *] new()
constructor method.  This is shown in the example below where the
'Foo' is located as 'My::Plugin::Foo' or 'Your::Plugin::Foo' but not 
as 'Template::Plugin::Foo'.

example 3:

    use Template::Plugins;
    $Template::Plugins::PLUGIN_BASE = '';

    my [* obj *] = [* pkg *]->new({
        PLUGIN_BASE => [   'My::Plugin',
                           'Your::Plugin'  ],
    });

    [% USE Foo %]    # =>   My::Plugin::Foo
                       or Your::Plugin::Foo 

